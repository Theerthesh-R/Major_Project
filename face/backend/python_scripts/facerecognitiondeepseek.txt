import os
import sys
import time
import cv2
import numpy as np
import torch
from facenet_pytorch import MTCNN, InceptionResnetV1
import requests
import mysql.connector
import threading
import gc

# --------------------------
# Threaded RTSP Stream Reader with Error Handling
# --------------------------
class RTSPStream:
    def __init__(self, url):
        self.url = url
        self.cap = None
        self.ret = False
        self.frame = None
        self.lock = threading.Lock()
        self.running = True
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 5
        self._initialize_camera()
        threading.Thread(target=self.update, daemon=True).start()

    def _initialize_camera(self):
        try:
            if self.cap is not None:
                self.cap.release()
            self.cap = cv2.VideoCapture(self.url, cv2.CAP_FFMPEG)
            # Set lower resolution to reduce memory usage
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
            self.cap.set(cv2.CAP_PROP_FPS, 15)
            
            # Test if camera works
            for _ in range(5):  # Try a few times to get a frame
                ret, frame = self.cap.read()
                if ret and frame is not None:
                    self.ret, self.frame = ret, frame
                    self.reconnect_attempts = 0
                    print("‚úÖ Camera initialized successfully")
                    return
                time.sleep(0.1)
            
            raise Exception("Could not read frame from camera")
            
        except Exception as e:
            print(f"‚ùå Camera initialization failed: {e}")
            self.ret, self.frame = False, None
            self._attempt_reconnect()

    def _attempt_reconnect(self):
        if self.reconnect_attempts < self.max_reconnect_attempts:
            self.reconnect_attempts += 1
            print(f"üîÑ Attempting to reconnect ({self.reconnect_attempts}/{self.max_reconnect_attempts})...")
            time.sleep(2)
            self._initialize_camera()
        else:
            print("‚ùå Max reconnection attempts reached")
            self.running = False

    def update(self):
        while self.running:
            try:
                if self.cap is None or not self.cap.isOpened():
                    self._attempt_reconnect()
                    continue
                    
                ret, frame = self.cap.read()
                if not ret or frame is None:
                    print("‚ö†Ô∏è Failed to read frame, attempting reconnect...")
                    self._attempt_reconnect()
                    continue
                
                with self.lock:
                    self.ret, self.frame = ret, frame
                    
                self.reconnect_attempts = 0  # Reset on successful frame read
                
            except Exception as e:
                print(f"‚ùå Error in stream update: {e}")
                self._attempt_reconnect()
            time.sleep(0.03)  # Small delay to prevent excessive CPU usage

    def read(self):
        with self.lock:
            return self.ret, self.frame.copy() if self.frame is not None else None

    def release(self):
        self.running = False
        if self.cap is not None:
            self.cap.release()

# --------------------------
# GPU / CUDA setup with memory management
# --------------------------
def setup_device():
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f"Using device: {device}")
    
    # Clear GPU memory if using CUDA
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        print(f"GPU memory cleared")
    
    return device

device = setup_device()

# --------------------------
# Config
# --------------------------
USE_COSINE = True
THRESHOLD = 0.85
FRAMES_REQUIRED = 10
MAX_FACES_PER_FRAME = 10  # Limit number of faces to process

# --------------------------
# Face Detection + Embedding with memory optimization
# --------------------------
try:
    mtcnn = MTCNN(
        keep_all=True, 
        device=device,
        min_face_size=20,  # Increase min face size to reduce processing
        thresholds=[0.6, 0.7, 0.7],  # Adjust thresholds
        post_process=False
    )
    resnet = InceptionResnetV1(pretrained='vggface2').eval().to(device)
    
    # Disable gradients for inference
    for param in resnet.parameters():
        param.requires_grad = False
        
except Exception as e:
    print(f"‚ùå Error initializing models: {e}")
    sys.exit(1)

# --------------------------
# DB connection
# --------------------------
def get_db_connection():
    try:
        conn = mysql.connector.connect(
            host="localhost",
            user="root",
            password="password",
            database="majorproject",
            connection_timeout=30
        )
        return conn
    except Exception as e:
        print(f"‚ùå Database connection failed: {e}")
        return None

conn = get_db_connection()
if conn is None:
    print("‚ùå Could not connect to database, exiting...")
    sys.exit(1)

cursor = conn.cursor()

try:
    cursor.execute("""
        SELECT s.name, f.embedding FROM face_embeddings f
        JOIN students s ON s.student_id = f.student_id
    """)
    known_embeddings, names = [], []
    for name, emb_str in cursor.fetchall():
        emb = np.array(list(map(float, emb_str.strip('[]').split(','))))
        known_embeddings.append(emb)
        names.append(name)
    print(f"‚úÖ Loaded {len(names)} known faces from database")
except Exception as e:
    print(f"‚ùå Error loading embeddings: {e}")
    known_embeddings, names = [], []

# --------------------------
# Attendance marking
# --------------------------
already_marked = set()
detection_counts = {}

def mark_attendance(name):
    if name not in already_marked:
        try:
            r = requests.post("http://localhost:3000/attendance", json={"name": name}, timeout=5)
            if r.ok:
                already_marked.add(name)
                print(f"‚úÖ Attendance marked: {name}")
            else:
                print(f"‚ùå API failed ({r.status_code})")
        except Exception as e:
            print(f"‚ùå Error marking attendance: {e}")

# --------------------------
# Similarity function
# --------------------------
def cosine_similarity(a, b):
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# --------------------------
# Main loop with error handling
# --------------------------
def main():
    url = "rtsp://admin:Sahyadri%401234@192.168.1.108:554/cam/realmonitor?channel=1&subtype=0"
    stream = RTSPStream(url)

    cv2.namedWindow("Recognition - Dahua RTSP", cv2.WINDOW_NORMAL)
    cv2.resizeWindow("Recognition - Dahua RTSP", 800, 600)

    fps_time = time.time()
    frame_count = 0

    try:
        while True:
            try:
                ret, frame = stream.read()
                if not ret or frame is None:
                    print("‚ö†Ô∏è No valid frame, skipping...")
                    time.sleep(0.1)
                    continue

                # Process every 2nd frame to reduce load
                frame_count += 1
                if frame_count % 2 != 0:
                    continue

                # Resize frame to reduce processing load
                frame = cv2.resize(frame, (640, 480))
                rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

                # Detect faces with error handling
                try:
                    boxes, probs = mtcnn.detect(rgb_frame)
                except Exception as e:
                    print(f"‚ùå Face detection error: {e}")
                    boxes, probs = None, None

                if boxes is not None and len(boxes) > 0:
                    # Limit number of faces to process
                    if len(boxes) > MAX_FACES_PER_FRAME:
                        boxes = boxes[:MAX_FACES_PER_FRAME]
                        probs = probs[:MAX_FACES_PER_FRAME] if probs is not None else None

                    faces = []
                    h, w, _ = rgb_frame.shape
                    
                    for box in boxes:
                        x1, y1, x2, y2 = [int(b) for b in box]
                        x1, y1 = max(0, x1), max(0, y1)
                        x2, y2 = min(w, x2), min(h, y2)
                        
                        face_img = rgb_frame[y1:y2, x1:x2]
                        if face_img.size == 0:
                            continue
                            
                        face_img = cv2.resize(face_img, (160, 160))
                        face_tensor = torch.tensor(face_img).permute(2,0,1).unsqueeze(0).float()/255.0
                        faces.append(face_tensor)

                    if faces:
                        try:
                            faces_tensor = torch.cat(faces).to(device)
                            embeddings = resnet(faces_tensor).detach().cpu().numpy()

                            for i, box in enumerate(boxes[:len(faces)]):  # Ensure we don't exceed faces count
                                x1, y1, x2, y2 = [int(b) for b in box]
                                x1, y1 = max(0, x1), max(0, y1)
                                x2, y2 = min(w, x2), min(h, y2)

                                emb = embeddings[i]
                                name = "Unknown"
                                confidence_score = 0.0

                                if USE_COSINE:
                                    max_sim, best_match = -1, None
                                    for j, known_emb in enumerate(known_embeddings):
                                        sim = cosine_similarity(emb, known_emb)
                                        if sim > max_sim:
                                            max_sim, best_match = sim, names[j]
                                    confidence_score = max_sim
                                    if max_sim >= THRESHOLD:
                                        name = best_match

                                # Determine color based on confidence
                                color = (0, 255, 0) if confidence_score >= THRESHOLD else (0, 0, 255)

                                # Draw box & label + confidence
                                label = f"{name} ({confidence_score:.2f})"
                                cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                                cv2.putText(frame, label, (x1, y1 - 10),
                                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)

                                # Attendance logic
                                if name != "Unknown" and confidence_score >= THRESHOLD:
                                    detection_counts[name] = detection_counts.get(name, 0) + 1
                                    if detection_counts[name] >= FRAMES_REQUIRED and name not in already_marked:
                                        mark_attendance(name)
                                        detection_counts[name] = 0

                        except Exception as e:
                            print(f"‚ùå Error processing faces: {e}")
                            continue

                # Show FPS and info
                now = time.time()
                fps = 1 / (now - fps_time)
                fps_time = now
                
                cv2.putText(frame, f"FPS: {fps:.1f}", (10, 30),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)
                cv2.putText(frame, f"Threshold: {THRESHOLD}", (10, 60),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)
                cv2.putText(frame, f"Faces: {len(known_embeddings)}", (10, 90),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)

                cv2.imshow("Recognition - Dahua RTSP", frame)
                
                # Regular memory cleanup
                if frame_count % 50 == 0:
                    if torch.cuda.is_available():
                        torch.cuda.empty_cache()
                    gc.collect()

                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    break
                elif key == ord('r'):  # Reset attendance for testing
                    already_marked.clear()
                    detection_counts.clear()
                    print("üîÑ Attendance reset")

            except Exception as e:
                print(f"‚ùå Error in main loop: {e}")
                time.sleep(0.1)
                continue

    except KeyboardInterrupt:
        print("üõë Interrupted by user")
    except Exception as e:
        print(f"‚ùå Fatal error: {e}")
    finally:
        print("üßπ Cleaning up...")
        stream.release()
        cv2.destroyAllWindows()
        if conn:
            conn.close()
        if torch.cuda.is_available():
            torch.cuda.empty_cache()

if __name__ == "__main__":
    main()